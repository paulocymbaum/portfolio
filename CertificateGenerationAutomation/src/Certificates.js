/**
 * Core certificate generation functionality.
 * Handles the creation, population, and PDF conversion of certificates.
 */

var Certificates = (function() {
  /**
   * Generates a certificate PDF based on template and participant data.
   * @param {Object} formData - Data from form submission (keys are normalized: lowercase, underscores for spaces).
   *                            Should include 'course_completion_date' as a Date object.
   * @return {Object} Certificate metadata including name, course, pdfUrl, certificateId, issuedDate.
   */
  function generateCertificate(formData) {
    const templateId = AppUtils.extractIdFromUrl(CONFIG.TEMPLATE_SLIDE_URL, 'slide');
    const outputFolderId = AppUtils.extractIdFromUrl(CONFIG.OUTPUT_FOLDER_URL, 'folder');

    if (!templateId) throw new Error('Invalid Slide Template URL in configuration.');
    if (!outputFolderId) throw new Error('Invalid Output Folder URL in configuration.');

    // --- Data Mapping ---
    // Retrieve data using the normalized keys generated by onFormSubmit
    // Provide default values if a key is missing in formData
    const name = formData.full_name || 'Unknown Participant'; // Use 'full_name'
    const course = formData.course_name || 'Unknown Course';   // Use 'course_name'
    const duration = formData.course_duration || '';         // Use 'course_duration'
    const email = formData.email || ''; // Assuming email is collected/present
    // Use the completion date from the form data. Default to now only as a fallback.
    const completionDate = formData.course_completion_date instanceof Date ? formData.course_completion_date : new Date();

    const certificateId = AppUtils.generateUniqueId();
    const issuedDate = completionDate; // Use the completion date as the issued date
    let tempSlideId = null; // Initialize tempSlideId here

    try {
      // 1. Copy the template slide
      tempSlideId = copyTemplate(name); // Assign the ID here

      if (!tempSlideId) {
          throw new Error('Failed to copy template slide. Check logs.');
      }

      // 2. Fill placeholders - Define the mapping from placeholder key to value
      const placeholders = {
        '{{NAME}}': name,
        '{{COURSE}}': course,
        '{{DURATION}}': duration,
        // Format the completion date for the placeholder
        '{{DATE}}': Utilities.formatDate(issuedDate, Session.getScriptTimeZone(), 'dd/MM/yyyy'),
        '{{CERTIFICATE_ID}}': certificateId
        // Add other placeholders if needed, e.g.:
        // '{{EMAIL}}': email
      };
      fillPlaceholders(tempSlideId, placeholders);

      // 3. Save as PDF
      const pdfFile = convertToPDF(tempSlideId, name);

      if (!pdfFile) {
          // If PDF conversion fails, still try to clean up the temp slide before throwing
          if (tempSlideId) {
            try {
              DriveApp.getFileById(tempSlideId).setTrashed(true);
              Logger.log('Cleaned up temporary slide (ID: ' + tempSlideId + ') after PDF conversion failure.');
            } catch (cleanupError) {
              AppUtils.logError('Non-critical: Failed to cleanup temp slide (ID: ' + tempSlideId + ') after PDF conversion failure', cleanupError);
            }
          }
          throw new Error('Failed to convert slide to PDF. Check logs.');
      }
      const pdfUrl = pdfFile.getUrl();

      // 4. Clean up temporary slide IMMEDIATELY after successful PDF creation
      if (tempSlideId) {
        try {
          DriveApp.getFileById(tempSlideId).setTrashed(true);
          Logger.log('Temporary slide (ID: ' + tempSlideId + ') successfully trashed after PDF generation.');
        } catch (cleanupError) {
          // Log as non-critical if cleanup fails
          AppUtils.logError('Non-critical: Failed to trash temporary slide ID: ' + tempSlideId + ' after PDF generation', cleanupError);
        }
      }

      Logger.log('Certificate generated for ' + name + ': ' + pdfUrl);

      // Return metadata (using the correctly retrieved values)
      return {
        name: name,
        course: course,
        duration: duration,
        email: email, // Include email if needed downstream
        pdfUrl: pdfUrl,
        certificateId: certificateId,
        issuedDate: issuedDate.toISOString() // Return the completion date as the issuedDate
      };

    } catch (error) {
      // Use the globally exposed logError which should exist via Code.js forwarding to AppUtils.js
      if (typeof AppUtils !== 'undefined' && typeof AppUtils.logError === 'function') { // Check AppUtils exists
        AppUtils.logError('Certificate generation failed for ' + name, error); // Call via AppUtils
      } else {
        // Fallback if global logError isn't available for some reason
        Logger.log('Certificate generation failed for ' + name + '. Error: ' + error.toString() + '\nStack: ' + (error.stack || 'N/A'));
      }
      // Ensure cleanup is attempted even if an error occurs earlier (e.g., during placeholder filling)
      if (tempSlideId) {
        try {
          // Check if file exists before trying to trash, might have been deleted already or failed creation
          DriveApp.getFileById(tempSlideId).setTrashed(true);
          Logger.log('Cleaned up temporary slide (ID: ' + tempSlideId + ') during error handling.');
        } catch (cleanupError) {
          // Avoid logging if the error is just 'File not found'
          if (!cleanupError.message || !cleanupError.message.includes('No item with the given ID could be found')) {
             AppUtils.logError('Non-critical: Failed to cleanup temp slide (ID: ' + tempSlideId + ') during error handling', cleanupError);
          }
        }
      }
      // It's generally better to let the calling function (processNewSubmission) handle the overall failure
      // rather than re-throwing here, as processNewSubmission already has a try/catch.
      // Return null or a specific error object if needed, but avoid re-throwing the same error.
      return null; // Indicate failure to the caller
    }
  }

  /**
   * Creates a copy of the certificate template.
   * @param {string} studentName - Name to use in the temporary file name
   * @return {string | null} ID of the created slide copy, or null on failure.
   */
  function copyTemplate(studentName) {
    const templateUrl = CONFIG.TEMPLATE_SLIDE_URL;
    const templateId = templateUrl ? AppUtils.extractIdFromUrl(templateUrl, 'slide') : null;

    if (!templateId) {
        // Use global logError if available
        if (typeof AppUtils !== 'undefined' && typeof AppUtils.logError === 'function') { // Check AppUtils exists
            AppUtils.logError('Template Slide URL is not configured or invalid: ' + templateUrl, null); // Call via AppUtils
        } else {
            Logger.log('ERROR: Template Slide URL is not configured or invalid: ' + templateUrl);
        }
        return null;
    }
    try {
      const templateFile = DriveApp.getFileById(templateId);

      // Sanitize the file name to avoid invalid characters
      const safeName = studentName ? studentName.replace(/[^\w\s-]/gi, '') : 'Unnamed';
      const newFileName = 'TEMP Certificate - ' + safeName + ' - ' +
                           Utilities.formatDate(new Date(), Session.getScriptTimeZone(), 'yyyy-MM-dd-HH-mm-ss');

      // Create a copy in the root folder temporarily (easier cleanup)
      const copy = templateFile.makeCopy(newFileName);
      Logger.log('Template copied (ID: ' + templateId + '). New slide ID: ' + copy.getId());
      return copy.getId();
    } catch (error) {
      // Use global logError if available
      if (typeof AppUtils !== 'undefined' && typeof AppUtils.logError === 'function') { // Check AppUtils exists
          AppUtils.logError('Failed to copy template slide ID: ' + templateId + ' from URL: ' + templateUrl, error); // Call via AppUtils
      } else {
          Logger.log('ERROR: Failed to copy template slide ID: ' + templateId + ' from URL: ' + templateUrl + '. Error: ' + error.toString());
      }
      return null;
    }
  }

  /**
   * Fills in placeholders in the slide with actual data.
   * @param {string} slideId - ID of the slide to modify
   * @param {Object} placeholderData - Participant data to insert (keys should match placeholders like {{KEY}})
   * @throws {Error} If slide cannot be opened or placeholders cannot be filled.
   */
  function fillPlaceholders(slideId, placeholderData) {
    let presentation = null; // Define presentation outside try block for potential closing in finally
    let totalReplacementsMade = 0; // Track total replacements across all placeholders
    try {
      presentation = SlidesApp.openById(slideId);
      const slides = presentation.getSlides();

      if (slides.length === 0) {
        throw new Error('Template slide (' + slideId + ') has no slides.');
      }

      const slide = slides[0]; // Assume first slide is the certificate

      Logger.log('Replacing placeholders in slide ID: ' + slideId + ' using slide.replaceAllText with data: ' + JSON.stringify(placeholderData));

      // Iterate through the placeholder data and replace each one on the slide
      for (const placeholder in placeholderData) {
        if (placeholderData.hasOwnProperty(placeholder)) {
          // Ensure value is a string for replaceAllText
          const value = String(placeholderData[placeholder] || ''); // Use empty string if null/undefined
          // slide.replaceAllText is case-sensitive. Ensure template matches exact case {{PLACEHOLDER}}.
          const numReplaced = slide.replaceAllText(placeholder, value);
          if (numReplaced > 0) {
            Logger.log(`Replaced ${numReplaced} instance(s) of ${placeholder}`);
            totalReplacementsMade += numReplaced;
          } else {
            // Log if a placeholder defined in the map wasn't found in the slide
            Logger.log(`WARNING: Placeholder ${placeholder} not found in slide ID: ${slideId}`);
          }
        }
      }

      Logger.log('Total placeholder instances replaced via slide.replaceAllText: ' + totalReplacementsMade);

      // Save the changes - saveAndClose might not be needed if replaceAllText saves implicitly, but it's safer to keep.
      presentation.saveAndClose();
      presentation = null; // Nullify after successful close

    } catch (error) {
      AppUtils.logError('Failed to fill placeholders in slide ID: ' + slideId, error);
      throw error; // Re-throw to be caught by generateCertificate
    } finally {
        // Ensure presentation is closed even if an error occurs after opening
        if (presentation) {
            try {
                presentation.saveAndClose();
                Logger.log('Ensured presentation was closed in finally block for slide ID: ' + slideId);
            } catch (closeError) {
                AppUtils.logError('Error closing presentation in finally block for slide ID: ' + slideId, closeError);
            }
        }
    }
  }

  /**
   * Converts the slide to PDF and saves it to the output folder.
   * @param {string} slideId - ID of the slide to convert
   * @param {string} studentName - Name to use in the final PDF file name
   * @return {File | null} The Google Drive File object for the PDF, or null on failure.
   * @throws {Error} If the output folder URL is not configured or invalid.
   */
  function convertToPDF(slideId, studentName) {
    const outputFolderUrl = CONFIG.OUTPUT_FOLDER_URL;
    const outputFolderId = outputFolderUrl ? AppUtils.extractIdFromUrl(outputFolderUrl, 'folder') : null;

    if (!outputFolderId) {
        const errorMsg = 'Output Folder URL is not configured or invalid: ' + outputFolderUrl;
        // Use global logError if available
        if (typeof AppUtils !== 'undefined' && typeof AppUtils.logError === 'function') { // Check AppUtils exists
            AppUtils.logError(errorMsg, null); // Call via AppUtils
        } else {
            Logger.log('ERROR: ' + errorMsg);
        }
        throw new Error(errorMsg); // Throw error as this is critical
    }

    try {
      const outputFolder = DriveApp.getFolderById(outputFolderId);
      const slideFile = DriveApp.getFileById(slideId); // Get the temporary slide file

      // Get the blob of the file as PDF using UrlFetchApp for reliability
      const slidesUrl = 'https://docs.google.com/presentation/d/' + slideId + '/export/pdf';
      const response = UrlFetchApp.fetch(slidesUrl, {
        headers: {
          Authorization: 'Bearer ' + ScriptApp.getOAuthToken()
        },
        muteHttpExceptions: true // Prevent throwing errors for HTTP issues, check response code instead
      });

      if (response.getResponseCode() !== 200) {
          const errorDetail = 'Failed to fetch PDF export for slide ID: ' + slideId + '. Response code: ' + response.getResponseCode() + ', Response body: ' + response.getContentText();
          // Use global logError if available
          if (typeof AppUtils !== 'undefined' && typeof AppUtils.logError === 'function') { // Check AppUtils exists
              AppUtils.logError(errorDetail, null); // Call via AppUtils
          } else {
              Logger.log('ERROR: ' + errorDetail);
          }
          return null;
      }

      const pdfBlob = response.getBlob();

      // Sanitize the file name
      const safeName = studentName ? studentName.replace(/[^\w\s-]/gi, '') : 'Unnamed';
      const pdfFileName = 'Certificate - ' + safeName + ' - ' +
                          Utilities.formatDate(new Date(), Session.getScriptTimeZone(), 'yyyy-MM-dd') + '.pdf';
      pdfBlob.setName(pdfFileName);

      // Save to the output folder
      const pdfFile = outputFolder.createFile(pdfBlob);

      // Make it viewable by anyone with the link (adjust permissions as needed)
      pdfFile.setSharing(DriveApp.Access.ANYONE_WITH_LINK, DriveApp.Permission.VIEW);

      Logger.log('PDF certificate created: ' + pdfFile.getName() + ' in folder ID: ' + outputFolderId + ' (from URL: ' + outputFolderUrl + ')');
      return pdfFile;

    } catch (error) {
      // Use global logError if available
      if (typeof AppUtils !== 'undefined' && typeof AppUtils.logError === 'function') { // Check AppUtils exists
          AppUtils.logError('Failed to convert slide ID ' + slideId + ' to PDF in folder ID ' + outputFolderId, error); // Call via AppUtils
      } else {
          Logger.log('ERROR: Failed to convert slide ID ' + slideId + ' to PDF in folder ID ' + outputFolderId + '. Error: ' + error.toString());
      }
      return null;
    }
  }

  // Public API
  return {
    generateCertificate: generateCertificate
  };
})(); // End of IIFE